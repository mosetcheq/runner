<?php namespace Rnr { use \PDO; class DBStatement { public $OS; public function __construct($statement) { $this->OS = $statement; } public function __call($name, $arguments) { return call_user_func_array([$this->OS, $name], $arguments); } public function Exec($data = null) { $this->OS->execute($data); return $this; } public function Fetch($className = null) { return $this->OS->FetchObject($className); } public function FetchGroup() { return $this->OS->fetchAll(PDO::FETCH_GROUP|PDO::FETCH_OBJ); } public function FetchByColumn($col_index = 0) { return $this->OS->fetchAll(PDO::FETCH_COLUMN, $col_index); } } class DB { private static $PDO; public static $Prefix; private static $PDOStatement; public static $debug = false; public static $totaltime = 0; public static function Connect($server, $user, $password, $database, $prefix = null) { self::$Prefix = $prefix; try { self::$PDO = new PDO("mysql:host={$server};dbname={$database}", $user, $password, array(PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8')); } catch(\PDOException $e) { Log::Write('Database error: '.$e->getMessage()); ErrorHandling::SQL(null, $e->getMessage()); } } public static function getAttr($atr) { return @self::$PDO->getAttribute(constant('PDO::ATTR_'.$atr)); } private static function Q($query) { if(DB_DEBUGMODE) Log::Write($query); $start = microtime(true); if(!$statement = self::$PDO->query($query)) { $err = self::$PDO->errorInfo(); Log::Write($err[1].':'.$err[2]); if(!DisableWarnings) ErrorHandling::SQL($query, $err); if(DB_DEBUGMODE) echo($query.'<br>'.$err[1].':'.$err[2]); exit(); } self::$totaltime += (microtime(true) - $start); self::$PDOStatement = $statement; return new DBStatement($statement); } public static function Query($query) { return self::Q($query); } public static function Prepare($query) { if(DB_DEBUGMODE) Log::Write('Prepare '.$query); return new DBStatement(self::$PDO->prepare($query)); } public static function PrepQuery($query, $data) { if(DB_DEBUGMODE) Log::Write('Prepare '.$query); $statement = self::$PDO->prepare($query); if(!$statement->execute($data)) { if(!DisableWarnings) ErrorHandling::SQL($query, $statement->errorInfo()); } self::$PDOStatement = $statement; return new DBStatement($statement); } public static function getObject($classname = 'stdClass') { return self::$PDOStatement->FetchObject($classname); } public static function Get($classname = 'stdClass') { return self::$PDOStatement->FetchObject($classname); } public static function Exec($query) { if(DB_DEBUGMODE) Log::Write($query); return self::$PDO->exec($query); } public static function PrepExec($query, $data) { if(DB_DEBUGMODE) Log::Write('Prepare '.$query."\nValues:".print_r($data, true)); $statement = self::$PDO->prepare($query); if(!$statement->execute($data)) { if(!DisableWarnings) ErrorHandling::SQL($query, $statement->errorInfo()); } return $statement; } public static function FetchAllRaw($query) { if(DB_DEBUGMODE) Log::Write($query); return self::$PDO->query($query)->FetchAll(PDO::FetchClass); } public static function FetchRow($query, $values = false, $objtype = null) { if(DB_DEBUGMODE) Log::Write($query); if(!$values) return self::$PDO->query($query)->FetchObject($objtype); else return self::PrepExec($query, $values)->FetchObject($objtype); } public static function FetchAll($query, $values = false, $objtype = null, $key = null, $callback = null) { if(DB_DEBUGMODE) Log::Write($query); $tmp = null; if(!$values) $q = self::$PDO->query($query); else $q = self::PrepExec($query, $values); if(!$q) { $err = self::$PDO->errorInfo(); Log::Write($err[1].':'.$err[2]); if(!DisableWarnings) ErrorHandling::SQL($query, $err); if(DB_DEBUGMODE) echo($query.'<br>'.$err[1].':'.$err[2]); exit(); } while($s = $q->FetchObject($objtype)) { if(is_callable($callback)) $s = call_user_func($callback, $s); if($key) $tmp[$s->$key] = $s; else $tmp[] = $s; } return $tmp; } public static function FetchDataRow($tablename, $where = null) { if(self::$Prefix) $tablename = self::$Prefix.'_'.$tablename; return self::$PDO->query('SELECT * FROM '.$tablename.($where ? ' WHERE '.$where : '').' LIMIT 1;')->FetchObject(); } public static function Insert($tablename, $data, $datafilter = false, $ignore = false) { if(self::$Prefix) $tablename = self::$Prefix.'_'.$tablename; if($datafilter) $data = array_filter($data); if($ignore) $ign = 'IGNORE '; $data = self::createInsertData($data, $datafilter); self::PrepExec("INSERT {$ign}INTO {$tablename} {$data['query']};", $data['pass']); return self::$PDO->lastInsertId(); } public static function Update($tablename, $data, $where = null, $limit = null) { if(self::$Prefix) $tablename = self::$Prefix.'_'.$tablename; if(is_array($where)) { $wh = []; foreach($where as $column => $value) if(gettype($value) == 'NULL') $wh[] = $column.' IS NULL'; else $wh[] = $column.' = \''.$value.'\''; $where = implode(' AND ', $wh); } if(is_array($data)) { $data = self::createUpdateData($data); return self::PrepExec("UPDATE {$tablename} SET {$data['query']}".($where ? ' WHERE '.$where : '').($limit ? ' LIMIT '.$limit : '').';', $data['pass']); } else return self::Exec("UPDATE {$tablename} SET {$data}".($where ? ' WHERE '.$where : '').($limit ? ' LIMIT '.$limit : '').';'); } public static function InsertUpdate($tablename, $insert, $update, $datafilter = false, $noID = false) { if(self::$Prefix) $tablename = self::$Prefix.'_'.$tablename; $data1 = self::createInsertData($insert, $datafilter); $data2 = self::createUpdateData($update, $datafilter); self::PrepExec("INSERT INTO {$tablename} {$data1['query']} ON DUPLICATE KEY UPDATE {$data2['query']}".(!$noID ? ', id = LAST_INSERT_ID(id)' : '').';', array_merge($data1['pass'], $data2['pass'])); return self::$PDO->lastInsertId(); } public static function InsertMultiple($tablename, $columns, $data, $ignore = false, $onduplicate = false) { foreach($data as $key => $values) { foreach($values as $k => $v) if(!is_null($v)) $values[$k] = '\''.addslashes($v).'\''; else $values[$k] = 'NULL'; $data[$key] = '('.implode(', ', $values).')'; } $query = 'INSERT'.($ignore ? ' IGNORE' : '')." INTO {$tablename} ({$columns}) VALUES ".implode(', ', $data).($onduplicate ? ' ON DUPLICATE KEY UPDATE '.$onduplicate : '').';'; if(DB_DEBUGMODE) Log::Write($query); return self::$PDO->exec($query); } public static function Delete($tablename, $where, $limit = null) { if(self::$Prefix) $tablename = self::$Prefix.'_'.$tablename; return self::Exec('DELETE FROM '.$tablename.($where ? ' WHERE '.$where : '').($limit ? ' LIMIT '.$limit : '').';'); } public static function createWhere($where) { if(is_array($where)) { $wh = []; foreach($where as $column => $value) if(gettype($value) == 'NULL') $wh[] = $column.' IS NULL'; else $wh[] = $column.' = \''.$value.'\''; $where = implode(' AND ', $wh); } return $where; } public static function createInsertData($data, $datafilter = false) { if($datafilter) $data = array_filter($data); $data_pass = array(); foreach($data as $key => $value) { switch(gettype($value)) { case('NULL'): $value = 'NULL'; break; case('array'): $value = implode(',', $value); break; default: if($value[0] == '$') $value = substr($value,1); else { $data_pass['i_'.$key] = $value; $value = ":i_{$key}"; } break; } $data[$key] = $value; } return array('query' => '('.implode(', ', array_keys($data)).') VALUES ('.implode(', ', $data).')', 'pass' => $data_pass); } public static function createUpdateData($data, $datafilter = false) { $data_pass = array(); foreach($data as $key => $value) { switch(gettype($value)) { case('NULL'): $value = 'NULL'; break; case('array'): $value = implode(',', $value); break; default: if($value[0] == '$') $value = substr($value,1); else { $data_pass['u_'.$key] = $value; $value = ":u_{$key}"; } break; } $tmp[] = "{$key} = {$value}"; } return array('query' => implode(', ', $tmp), 'pass' => $data_pass); } }  class ErrorHandling { private static $runtimeErrors = array(); private static $E_TYPE = array( 1 => 'E_ERROR', 2 => 'E_WARNING', 4 => 'E_PARSE', 8 => 'E_NOTICE', 16 => 'E_CORE_ERROR', 32 => 'E_CORE_WARNING', 64 => 'E_COMPILE_ERROR', 128 => 'E_COMPILE_WARNING', 256 => 'E_USER_ERROR', 512 => 'E_USER_WARNING', 1024 => 'E_USER_NOTICE', 2048 => 'E_STRICT', 4096 => 'E_RECOVERABLE_ERROR', 8192 => 'E_DEPRECATED', 16384 => 'E_USER_DEPRECATED' ); public static function ShutDown() { $halt_on = E_ERROR | E_PARSE | E_USER_ERROR | E_WARNING; $error = error_get_last(); if((count(self::$runtimeErrors) > 0) || ($error['type'] & $halt_on)) { if($error['type'] & $halt_on) $error = array_values($error); else $error = self::$runtimeErrors[count(self::$runtimeErrors)-1]; if($error[0] & $halt_on) self::Critical($error[0], $error[1], $error[2], $error[3]); else self::RuntimeReport(); } } public static function Runtime($err_no, $err_str, $err_file, $err_line, $err_context = null) { self::$runtimeErrors[] = array($err_no, $err_str, $err_file, $err_line); if($err_no != E_USER_ERROR) return true; else return false; } public static function Critical($err_no, $err_str = null, $err_file = null, $err_line = null, $err_context = null) { ob_clean(); ob_start(); if(($err_no != E_USER_ERROR) && ($err_file) && ErrorEnableSource) { $start_add = $end_add = true; $source = file($err_file); $eline = $err_line - 1; $start = $err_line - 10; if($start<0) { $start = 0; $start_add = false; } $end = $err_line + 10; if($end>=sizeof($source)) { $end = sizeof($source)-1; $end_add = false; } $patterns = array( '/(abstract|and|array|break|callable|case|catch|class|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|eval|exit|extends|final|finally|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|new|or|print|private|protected|public|require|require_once|return|static|switch|throw|trait|try|unset|use|var|while|xor|yeld)(\W)/i', '/(null|bool|boolean|int|integer|float|decimal|str|string|object|resource|true|false)(\W)/i', '/(\$(\w|\d|_)*)/', '/(\'[^\']*\')/', '/(&quot;[^\']*&quot;)/' ); $replaces = array( '<span class="keyw">$1</span>$2', '<span class="type">$1</span>$2', '<span class="var">$1</span>', '<span class="str">$1</span>', '<span class="str">$1</span>' ); for($line = $start; $line <= $end; $line++) { $source[$line] = htmlspecialchars(rtrim($source[$line])); $source[$line] = preg_replace($patterns, $replaces, $source[$line]); } } else $err_file = null; include(RnrDir.'error_critical.php'); self::send('Critical error'); exit; } public static function SQL($query, $info) { ob_clean(); ob_start(); $trace = debug_backtrace(); if(is_array($info)) { $error = $info[2]; array_shift($trace); } else $error = $info; $err_file = $trace[1]['file']; $err_line = $trace[1]['line']; if($err_file && ErrorEnableSource) { $start_add = $end_add = true; $source = file($err_file); $eline = $err_line - 1; $start = $err_line - 10; if($start<0) { $start = 0; $start_add = false; } $end = $err_line + 10; if($end>=sizeof($source)) { $end = sizeof($source)-1; $end_add = false; } $patterns = array( '/(abstract|and|array|break|callable|case|catch|class|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|eval|exit|extends|final|finally|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|new|or|print|private|protected|public|require|require_once|return|static|switch|throw|trait|try|unset|use|var|while|xor|yeld)(\W)/i', '/(null|bool|boolean|int|integer|float|decimal|str|string|object|resource|true|false)(\W)/i', '/(\$(\w|\d|_)*)/', '/(\'[^\']*\')/', '/(&quot;[^\']*&quot;)/' ); $replaces = array( '<span class="keyw">$1</span>$2', '<span class="type">$1</span>$2', '<span class="var">$1</span>', '<span class="str">$1</span>', '<span class="str">$1</span>' ); for($line = $start; $line <= $end; $line++) { $source[$line] = htmlspecialchars(rtrim($source[$line])); $source[$line] = preg_replace($patterns, $replaces, $source[$line]); } } include(RnrDir.'error_sql.php'); self::send('SQL error'); exit; } public static function RuntimeReport() { ob_start(); $errors = self::$runtimeErrors; include(RnrDir.'error_runtime.php'); self::send('Rutime errors'); exit; } public static function IsErrors() { return(count(self::$runtimeErros) > 0); } public static function send($err_type) { $data = ob_get_clean(); if(defined('ErrorEmail')) mail(ErrorEmail, $_SERVER['SERVER_NAME'].' '.$err_type, $data, "Content-transfer-encoding: 8bit\nContent-type: text/html; charset=utf-8\n"); if(!DisableWarnings) echo($data); } } set_error_handler('Rnr\ErrorHandling::Runtime', E_ALL ^ E_NOTICE); register_shutdown_function('Rnr\ErrorHandling::Shutdown');  class ErrorDocument { public function onLoad() { return ErrorDocument(404); } public function __call($func, $params) { return ErrorDocument(404); } }  define('OUTPUT_TEMPLATE', 1); define('OUTPUT_ERRORDOCUMENT', 2); define('OUTPUT_REDIRECT', 4); define('OUTPUT_JSON', 8); define('OUTPUT_PREVIOUS', 32); define('OUTPUT_PLAIN', 64); define('OUTPUT_FILE', 128); class OutputType { public $type; public $template; public $data1; public $data2; public function __construct($type, $template, $data1 = null, $data2 = null) { $this->type = $type; $this->template = $template; $this->data1 = $data1; $this->data2 = $data2; } } class Output { public static $HttpCodes = array( 100 => '1.0 100 Continue', 101 => '1.0 101 Switching protocol', 200 => '1.0 200 OK', 201 => '1.0 201 Created', 202 => '1.0 202 Accepted', 203 => '1.1 203 Non-authoritative information', 204 => '1.0 204 No content', 205 => '1.0 205 Reset Content', 206 => '1.0 206 Partial Content', 300 => '1.0 300 Multiple Choices', 301 => '1.0 301 Moved Permanently', 302 => '1.0 302 Found', 303 => '1.1 303 See Other', 304 => '1.0 304 Not Modified', 305 => '1.1 305 Use Proxy', 307 => '1.1 307 Temporary Redicect', 400 => '1.0 400 Bad Request', 401 => '1.0 401 Unauthorised', 403 => '1.0 403 Forbidden', 404 => '1.0 404 Not Found', 405 => '1.0 405 Method Not Allowed', 406 => '1.0 406 Not Acceptable', 407 => '1.0 407 Proxy Authentication Required', 408 => '1.0 408 Request Timeout', 409 => '1.0 409 Conflict', 410 => '1.0 410 Gone', 411 => '1.0 411 Length Required', 412 => '1.0 412 Precondition Failed', 413 => '1.0 413 Request Entity Too Large', 414 => '1.0 414 Request-URI Too Long', 415 => '1.0 415 Unsuported Media Type', 416 => '1.0 416 Requested Range Not Satisfiable', 417 => '1.0 417 Expectation Failed', ); public $contentType; public $charset; public $headers = array(); private $assigned = null; public function __construct($content = 'text/html', $charset = 'utf-8') { $this->contentType = $content; $this->charset = $charset; $this->data = new \StdClass(); } public function Assign($variable, $value) { $this->assigned[$variable] = $value; } public function __set($variable, $value) { $this->assigned[$variable] = $value; } public function GetAssigned($as_array = false) { if($as_array) return $this->assigned; else return (object)$this->assigned; } public function AddHTTPHeader($name, $value = null) { if($value) $this->headers[] = $name.': '.$value; else $this->headers[] = $name; } public function File($filename, $exit = false) { readfile($filename); if($exit) exit(); } public function PassToFile($source, $data = null) { ob_start(); if($data) $v = $view = (object)$data; else $v = $view = (object)$this->assigned; if(file_exists(TemplateOutput.$source.'.php')) include(TemplateOutput.$source.'.php'); elseif(file_exists(TemplateOutputCommon.$source.'.php')) include(TemplateOutputCommon.$source.'.php'); elseif(file_exists("html/{$source}.html")) include("html/{$source}.html"); return ob_get_clean(); } public function SendHeaders() { header('Content-type: '.$this->contentType.($this->charset ? '; charset='.$this->charset : '')); if($this->headers) foreach($this->headers as $header) header($header); } public static function HTML($text) { return htmlspecialchars($text); } } class Input { public static function QueryString() { return $_SERVER['QUERY_STRING']; } public static function RequestMethod() { return $_SERVER['REQUEST_METHOD']; } public static function IsPost() { return ($_SERVER['REQUEST_METHOD'] == 'POST'); } public static function IsGet() { return ($_SERVER['REQUEST_METHOD'] == 'GET'); } public static function IsAJAX() { return (((!empty($_SERVER['HTTP_X_REQUESTED_WITH']) && (strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest')) || ($_GET[AjaxFlag]) || ($_POST[AjaxFlag]))); } public static function Post($varname) { return $_POST[$varname]; } public static function Files($varname) { return $_FILES[$varname]; } public static function Get($varname) { return $_GET[$varname]; } public static function Cookie($varname) { return $_COOKIE[$varname]; } public static function IsSubmited($formID) { if(($_POST[formIdentificator] == $formID) || ($_GET[formIdentificator] == $formID)) return true; else return false; } public static function Self() { return $_SERVER['REQUEST_URI']; } public static function IsFiles() { return count($_FILES); } public static function FilterSelf($removes) { $tmp = explode('?', $_SERVER['REQUEST_URI']); parse_str($tmp[1], $params); $remove = explode(',', $removes); $new = array(); foreach($params as $var => $param) if(!in_array($var, $remove)) $new[$var] = $param; $tmp[1] = http_build_query($new); if($tmp[1]) $tmp = implode('?', $tmp); else $tmp = $tmp[0]; return $tmp; } public static function Referer() { return $_SERVER['HTTP_REFERER']; } public static function GetStream() { return file_get_contents('php://input'); } } class Request { public function __construct() { $this->method = $_SERVER['REQUEST_METHOD']; $this->isAjax = (((!empty($_SERVER['HTTP_X_REQUESTED_WITH']) && (strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest')) || ($_GET[AjaxFlag]) || ($_POST[AjaxFlag]))); $this->post = (object)$_POST; $this->get = (object)$_GET; $this->cookie = (object)$_COOKIE; $this->contentType = $_SERVER['CONTENT_TYPE']; $this->body = file_get_contents('php://input'); $this->referer = $_SERVER['HTTP_REFERER']; $this->headers = (object)getallheaders(); switch($this->content_type) { case('application/json'): $this->data = JSON_decode($this->body); break; case('application/xml'): $this->data = SimpleXML_load_string($this->body); break; case('application/x-www-form-urlencoded'): parse_str($this->body, $this->data); break; } } } class PostData { public function __construct() { $tmp = file_get_contents('php://input'); if($tmp) { switch($_SERVER['CONTENT_TYPE']) { case('application/json'): $out = JSON_decode($tmp); break; case('application/xml'): $out = SimpleXML_load_string($tmp); break; case('application/x-www-form-urlencoded'): parse_str($tmp, $out); break; } foreach($out as $param => $value) $this->$param = $value; } } } class Session { public function __construct($ses_id = null) { if($ses_id) session_name($ses_id); session_start(); } public function __set($name, $val) { $_SESSION[$name] = $val; } public function __get($name) { return $_SESSION[$name]; } public function destroy() { return session_destroy(); } } class UploadedFile { public function __construct($file = null) { if(is_array($file)) foreach($file as $key => $value) $this->$key = $value; $tmp = explode('.', $this->name); $this->extension = array_pop($tmp); $this->shortname = implode('.', $tmp); } public function IsImage() { return preg_match('/image\/(.+)/', $this->type); } public function Move($directory, $name = '') { return move_uploaded_file($this->tmp_name, $directory.'/'.($name ? $name : $this->name)); } } class UploadedFileIterator implements \Iterator { private $files; private $pointer; public function __construct($prefix) { if(is_array($_FILES[$prefix]['name'])) { foreach($_FILES[$prefix]['name'] as $fkey => $name) { $this->files[$fkey] = new UploadedFile(); foreach(array_keys($_FILES[$prefix]) as $akey) $this->files[$fkey]->$akey = $_FILES[$prefix][$akey][$fkey]; } } else { $this->files[0] = new UploadedFile($_FILES[$prefix]); } $this->pointer = 0; } function rewind() { $this->pointer = 0; } function current() { return $this->files[$this->pointer]; } function key() { return $this->pointer; } function next() { ++$this->pointer; } function valid() { return isset($this->files[$this->pointer]); } } class_alias('Rnr\Output', '\Out'); class_alias('Rnr\Input', '\In');  class StopWatch { private $start = null; public function __construct() { $this->start = microtime(true); } public function __toString() { return (string)round((microtime(true) - $this->start)*1000, 3); } } class Log { public static function Write($str) { if(is_array($str) || is_object($str)) $str = print_r($str, true); $fh = fopen('application.log', 'a'); fputs($fh, date('Y-m-d H:i:s', time()).(AdvLog ? ' / T+'.(string)$GLOBALS['GlobalTime'] : '').'ms '.$str."\n"); fclose($fh); } } class Conv { public static function IntValue($str) { preg_match('/\d+/', $str, $match); return $match[0]; } public static function DecimalValue($str) { preg_match('/(\d|\.|,)+/', $str, $match); if($match[0]) { $out = str_replace(',', '.', $match[0]); return $out; } else return false; } public static function ArrayToObject($in) { if(is_array($in)) { $tmp = new \stdClass(); foreach($in as $name => $value) $tmp->$name = $value; return $tmp; } else return false; } public static function ObjectToArray($in) { if(is_object($in)) { foreach($in as $name => $value) $tmp[$name] = $value; return $tmp; } else return false; } public static function Translate($obj, $table) { if(!is_object($obj) || !is_array($table)) return false; $props = get_object_vars($obj); foreach($props as $prop => $value) { if($table[$prop]) $obj->$table[$prop] = $value; unset($obj->$prop); } return $obj; } } class Validator { private $fields = []; public $data = []; public $errors = []; public function __construct($data) { $this->data = $data; } public function Add($fieldName, $regexp) { $this->fields[] = [$fieldName, $regexp]; return $this; } public function Validate() { $this->errors = []; foreach($this->fields as $item) if(!preg_match("/{$item[1]}/", $this->data[$item[0]])) $this->errors[] = $item[0]; return (count($this->errors) == 0); } public function GetInvalidFields() { return $this->errors; } }  class RouterStatus { public $className = null; public $method = null; public $status = null; public $params = null; public function __construct($class, $method, $status = null, $params = array()) { $this->className = $class; $this->method = $method; $this->status = $status; $this->params = $params; } } define('RTR_TEXT', 0); define('RTR_REQUIRED', 1); define('RTR_REGEXP', 2); define('RTR_OPTIONAL', 3); define('RTR_ALL', 4); define('RTR_SKIP', 5); define('RTR_CONTINUE', 1); define('RTR_NOCHECKSIZE', 2); define('RTR_REVERSE', 4); define('RTR_ADDPARAMS', 8); define('RTR_ADDPARAMSARRAY', 16); define('RTR_API_MODE', 32); define('RTR_NONE', 0); define('RTR_OK', 1); define('RTR_NOTFOUND', -1); function Router($routes, $request, $defaults = null) { if(is_array($routes)) { $exit = false; $request = array_filter(explode('/', $request), function($i) {return trim($i) != '';}); if(count($request) > 0) { while(($route = array_shift($routes)) && (!$exit)) { $passed = true; $worker = $request; $params = array(); if($route['flags'] & RTR_REVERSE) $worker = array_reverse($worker); if(!($route['flags'] & RTR_NOCHECKSIZE) && (count($worker) != count($route['route']))) $passed = false; while(($element = array_shift($route['route'])) && ($passed)) { $u_item = array_shift($worker); switch($element[1]) { case RTR_TEXT: if($element[0] == $u_item) $passed = true; else $passed = false; break; case RTR_REQUIRED: if($u_item) $params[] = $u_item; else $passed = false; break; case RTR_REGEXP: if(preg_match("/{$element[0]}/", $u_item, $tmp)>0) $params[] = $tmp[1]; else $passed = false; break; case RTR_OPTIONAL: if($u_item) $params[] = $u_item; break; case RTR_ALL: array_unshift($worker, $u_item); $params[] = implode('/', $worker); break; case RTR_SKIP: array_unshift($worker, $u_item); break; default: $passed = false; break; } } if($passed) { list($class, $method) = $route['action']; if(strpos($class, '*') !== false) $class = rtrim(str_replace('*', array_shift($params), $class),'_\\'); if($method == '*') $method = array_shift($params); if($route['flags'] & RTR_API_MODE) $method = 'on'.ucfirst(strtolower($_SERVER['REQUEST_METHOD'])).ucfirst($method); if(($route['flags'] & RTR_ADDPARAMS) && (count($worker) > 0)) $params = array_merge($params, $worker); if(($route['flags'] & RTR_ADDPARAMSARRAY) && (count($worker) > 0)) $params = array($worker); $output = new RouterStatus($class, $method, RTR_OK, $params); if(!($route['flags'] & RTR_CONTINUE)) $exit = true; } } if(!$output) $output = new RouterStatus($defaults->className, $defaults->method, RTR_NOTFOUND, $request); return $output; } else return new RouterStatus($defaults->className, $defaults->method, RTR_NONE); } else return false; } } namespace { function autoloader($className) { $classFileName = str_replace('\\', '/', strtolower($className)); if(file_exists(AppClassDir.$classFileName.'.php')) require_once(AppClassDir.$classFileName.'.php'); else { require_once(RnrDir.'errordocument.php'); class_alias('Rnr\ErrorDocument', $className); } } function Template($filename) { return new Rnr\OutputType(OUTPUT_TEMPLATE, $filename, null, null); } function Plain($text, $contentType = 'text/plain', $charset = 'utf-8') { return new Rnr\OutputType(OUTPUT_PLAIN, $text, $contentType, $charset); } function ErrorDocument($error, $usertemplate = null) { return new Rnr\OutputType(OUTPUT_ERRORDOCUMENT, $usertemplate, $error, null); } function Redirect($url, $code = null) { return new Rnr\OutputType(OUTPUT_REDIRECT, null, $url, $code); } function JSON($data) { return new Rnr\OutputType(OUTPUT_JSON, null, $data, null); } function Previous() { return new Rnr\OutputType(OUTPUT_PREVIOUS, null, null, null); } function FileContent($source, $content = null, $filename = null) { return new Rnr\OutputType(OUTPUT_FILE, $source, $content, $filename); } function Inject($class, $method, $arguments) { try { $r = new ReflectionMethod($class, $method); } catch (Exception $e) { trigger_error("Runner ERROR: Unhandled '{$method}' action in '{".class_name($class)."' class", E_USER_ERROR); } $obj_params = []; foreach($r->getParameters() as $p) { $className = $p->getClass()->name; $obj_params[] = ($className ? new $className : array_shift($arguments)); } return array_merge($obj_params, $arguments); } spl_autoload_register('autoloader'); use Rnr\utf8; use Rnr\DB; use Rnr\StopWatch; use Rnr\Log; header('Cache-Control: no-cache, no-store, must-revalidate'); header('Pragma: no-cache'); header('Expires: 0'); $GlobalTime = new StopWatch(); if(AdvLog) Log::Write(' *** Starting session *** '); if(file_exists(RnrDir.'routes.php')) { require(RnrDir.'routes.php'); define('URLModeRouter', true); $runnerAction = Rnr\Router($routes, $_GET[rewriteVariable], new Rnr\RouterStatus(defaultModule, defaultAction)); } else { $params = $_GET; unset($params[ParamModule], $params[ParamAction]); $runnerAction = new Rnr\RouterStatus($_GET[ParamModule] ? $_GET[ParamModule] : defaultModule, $_GET[ParamAction], RTR_OK, $params); } if(!$runnerAction->method) $runnerAction->method = defaultGlobalAction; $Runner = new $runnerAction->className; if(!$output) $output = new Rnr\OutputType(null, null, null); if(method_exists($Runner, 'onLoad')) $output = call_user_func([$Runner, 'onLoad'], Inject($Runner, 'onLoad', [])); if(($_SERVER['REQUEST_METHOD'] == 'POST') && StreamAsParameter){ switch($_SERVER['CONTENT_TYPE']) { case('application/json'): array_push($runnerAction->params, JSON_decode(In::GetStream())); break; case('application/xml'): array_push($runnerAction->params, SimpleXML_load_string(In::GetStream())); break; } } if(count($_POST) > 0) { $postData = $_POST; if($_POST[formIdentificator]) { $formID = $_POST[formIdentificator]; $method_name = "on{$formID}Submit"; unset($postData[formIdentificator]); if(is_array($postData[$formID])) $postData = $postData[$formID]; } else $method_name = 'onPostData'; if(method_exists($Runner, $method_name)) $output = call_user_func_array([$Runner, $method_name], Inject($Runner, $method_name, $postData)); elseif(!DisableWarnings) trigger_error("Runner WARNING: Unhandled '{$method_name}/POST' event", E_USER_ERROR); } if($_GET[formIdentificator]) { $getData = $_GET; $method_name = 'on'.$_GET[formIdentificator].'Submit'; unset($getData[formIdentificator]); $getData = array_filter($getData); if(method_exists($Runner, $method_name)) $output = call_user_func_array([$Runner, $method_name], Inject($Runner, $method_name, $getData)); elseif(!DisableWarnings) trigger_error("Runner WARNING: Unhandled '{$method_name}/GET' event", E_USER_ERROR); } if($output->type == null) { if(method_exists($Runner, $runnerAction->method)) $output = call_user_func_array([$Runner, $runnerAction->method], Inject($Runner, $runnerAction->method, $runnerAction->params)); elseif(!DisableWarnings) trigger_error("Runner ERROR: Unhandled '{$runnerAction->method}' action in '{$runnerAction->className}' class", E_USER_ERROR); } if(($output->type == OUTPUT_TEMPLATE) && (method_exists($Runner, 'BeforeRender'))) call_user_func_array([$Runner, 'BeforeRender'], Inject($Runner, 'BeforeRender', [])); if(($output->type == null) && (!DisableWarnings)) trigger_error('Runner WARNING: NULL output', E_USER_ERROR); if($output->type == OUTPUT_ERRORDOCUMENT) { if($output->template == null) $output->template = ErrorDocumentName.$output->data1; $message = Rnr\Output::$HttpCodes[$output->data1]; if((!$message) && (!DisabledWarnings)) trigger_error('Runner/Output Error: &quot;'.$output->data1.'&quot; is not valid HTTP code'); header('HTTP/'.$message); $output->type = OUTPUT_TEMPLATE; } header('Memory: '.round(memory_get_peak_usage() / 1024 / 1024, 3).'MB (peak) / '.round(memory_get_usage() / 1024 / 1024, 3).'MB'); header('Time: '.$GlobalTime); switch($output->type) { case(OUTPUT_TEMPLATE): if(UseHTMLCompiler) { include(RnrDir.'templatecompiler.php'); new Template($output->template); } $Runner->view->SendHeaders(); $v = $view = $Runner->view->GetAssigned(); $v->SCRIPT_TIME = (string)$GlobalTime; ob_start(); if(file_exists(TemplateOutput.$output->template.'.php')) include(TemplateOutput.$output->template.'.php'); elseif(file_exists(TemplateOutputCommon.$output->template.'.php')) include(TemplateOutputCommon.$output->template.'.php'); else trigger_error('Runner/Ouput Error: template &quot;'.$output->template.'&quot; not found', E_USER_ERROR); $output = ob_get_clean(); if(method_exists($Runner, 'AfterRender')) call_user_func_array([$Runner, 'AfterRender'], Inject($Runner, 'AfterRender', [])); if(method_exists($Runner, 'OutputProcessing')) $output = call_user_func_array([$Runner, 'OutputProcessing'], Inject($Runner, 'OutputProcessing', $output)); echo($output); break; case(OUTPUT_PLAIN): header('Content-type: '.$output->data1.($output->data2 ? ';charset='.$output->data2 : '')); echo($output->template); break; case(OUTPUT_JSON): header('Content-type: application/json'); echo(json_encode($output->data1)); exit(); break; case(OUTPUT_REDIRECT): if($output->data2) header('Location: '.$output->data1, true, $output->data2); else header('Location: '.$output->data1); break; case(OUTPUT_PREVIOUS): header('Location: '.$_SERVER['HTTP_REFERER']); break; case(OUTPUT_FILE): if($output->data1) header('Content-type: '.$output->data1); if($output->data2) header('Content-Disposition: attachment; filename="'.$output->data2.'"'); readfile($output->template); break; } flush(); }